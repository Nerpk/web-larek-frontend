# Проектная работа "Веб-ларек"

Стек: HTML, SCSS, TS, Webpack

Структура проекта:
- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовым кодом

Важные файлы:
- src/pages/index.html — HTML-файл главной страницы
- src/types/index.ts — файл с типами
- src/index.ts — точка входа приложения
- src/styles/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами

## Установка и запуск
Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```
## Сборка

```
npm run build
```

или

```
yarn build
```

## Описание проекта
Проект WEB-larek реализует пример типового веб-магазина. Пользователь может добавлять и удалять товары в корзину, делать заказ с набранной корзиной. Проект реализован на TypeScript и представляет собой SPA (Single Page Application) с использованием API для получения данных о товарах и заказах.

Особенности реализации:
- товар можно добавить в корзину в единственном экземпляре
- заказ разделён на два модальных окна (способ оплаты + адрес и почта + телефон)
- после отправки заказа на сервер страница обновляется 

## Описание интерфейса 
Интерфейс можно разделить на 5 процессов:

1. Просмотр подробного описания товара 
2. Просмотр и редактирование корзины 
3. Оформление заказа (2 экрана)
4. Экран успешности заказа 

Так как модальные окна в проекте однотипные, их логика вынесена в класс ModalModel, отображение в ModalView, общая работа в класс ModalController. В проекте создан один объект модального окна, в который постепенно поступают данные для отображения, и как только они становятся не актуальны, контент в окне меняется.

## Структура проекта
. 
├── src/ 
│ ├── common.blocks/ [Стили компонент верстки] 
│ ├── components/ [Реализация] 
│ │ ├── base/ [Базовый код]
│ │ ├── model/ [Модели данных] 
│ │ ├── view/ [Отображения] 
│ │ ├── controller/ [Контроллеры]
│ ├── pages/ 
│ │ ├── index.html [Основная страница и шаблоны компонент] 
│ ├── types/ [Типизация] 
│ │ ├── components/ 
│ │ │ ├── base/ [Базовый код] 
│ │ │ ├── model/ [Модели данных и АПИ] 
│ │ │ ├── view/ [Отображения] 
│ ├── utils/ 
│ │ ├── constants.ts [Настройки проекта] 
│ │ ├── utils.ts [Утилиты для работы с DOM] 
├── api.yml [Спецификация API]

## Архитектура проекта (MVC)
Внутри контроллеров четырёх сущностей создаются модель и отображение. Модель и отображение взаимоддействуют друг с другом только по средвствам контроллера. Таким образом достигается отсутствие зависимости между логикой и оттображением элементов. 

Взаимодействие между контроллерами происходит благодаря классу EventEmmiter, при помощи которого контроллеры подписываются на события инициируемые друг другом. При надобности данных и/или отображения класса А внутри класса Б, класс Б инициирует событие, на которое подписан класс А, внутри которого в свою очередь и выполняется нужный по функционалу код. Таким образом достигается минимальная зависимость контроллеров друг от друга (в отличии от случая, где внутри кода класса А создаётся/передаётся как параметр класс Б).

Взаимодействия в коде можно представить так:
class A {
    constructor() {
        // ... код инициализации
    }

    someFunc(eve: EventEmitter) {
        // Инициирование события с данными о товаре
        eve.emit('addToCart', data);
    }
}

class B {
    constructor(eve: EventEmitter) {
        // Подписка на событие добавления в корзину
        eve.on('addToCart', this.someFunc(data));
    }

    someFunc(data) {
        // ... код функции
    }
}

## Отображения
Отображения разделены по сущностям создаваемым на странице. Типы BasketView, ProductView, OrderView, ModalView не зависят от внешних данных и могут быть переиспользованы в других проектах, также эти классы имеют собственную типизацию. ModalView полностью универсален для модальных окон, что делает его более переносимым в отличии от трёх други классов. 
Классы SuccessView и ProductListView зависят от глобальных данных, поэтому эти классы не могут быть переиспользованы. Классы созданы как вспомагательные, поэтому не имеют модели и контроллера, так как это было бы избыточным (единственный их функционал отрисовать полученые из вне данные). 

Каждое отображение (кроме вспомогательных) можно представить следующим образом:

class View {
    // данные нужные в отображении 

    constructor {
        // находим (если есть) селекторы соответствующие нужным дынным из шаблона в разметке
    } 

    public getSome() {
        return this.some
    }
    ... // возвращаем нужное поле (такие функции реализованы для каждого поля)
}

## Модели 
Модели представлены классами BasketModel, ProductModel, OrderModel, ModalModel. Они реализованы на основе данных нужных для сервера, в частности ProductModel, OrderModel, либо на основе данных нужных для логики работы, в частности BasketModel, ModalModel. 
Модели не зависимы друг от друга и используются только внутри контроллеров. 

Типовая модель представлена так:
class Model {
    // данные нужные для логики 

    constructor {
        // подставляем полученные данные
    } 

    public specificFunc() {
        // специфичные функции нужные, только в этой модели (например специфичная выдача информации удобная для заказа или функция преобразования объекта в линейный)
    }

    public getSome() {
        return this.some
    }
    ... // возвращаем нужное поле (такие функции реализованы для каждого поля)
}

## Контроллеры
Контроллеры в проекте представлены классами _Name_Controller. Они создают внутри себя модель и отображение объекта, а также занимаются их взаимодействием. Взаимодействие между контроллерами представленно в виде подписки на событие друг друга, по средствам класса EventEmmiter. В контроллерах происходит обработка событий и принятие решений, а также обновление данных в моделях.

Типичный контроллер представлен так:

class Controller {
    view: View; 
    model: Model;

    constructor (eve: eventEmmiter) {
        this.view = new View;
        this.model = new Model;

        eve.on('event', callback) ...
        // подписки на события (допустимо любое количество подписок)
    }

    public createItem(eve?: eventEmmiter) {
        // создание верного элемента отображения на основе данных из модели с повешенным функционалом на кнопки, инпуты и тд (реализация взаимодействия между моделью и отображением)
    }

    public specificFunc() {
        // специфичные функции нужные, только в этом контроллере 
    }
}

Таким образом взаимодействие происходит только между контроллерами, а соединения отображения и модели происходят внутри контроллера, что и соответствует MVC-модели.